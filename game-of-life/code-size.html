<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Shrinking `.wasm` Size - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./introduction.html"><strong>1.</strong> Introduction</a></li><li><a href="./background-and-concepts.html"><strong>2.</strong> Background And Concepts</a></li><li><a href="./setup.html"><strong>3.</strong> Setup</a></li><li><a href="./hello-world.html"><strong>4.</strong> Hello World</a></li><li><a href="./tools.html"><strong>5.</strong> Tools</a></li><li><a href="./workflows.html"><strong>6.</strong> Workflows</a></li><li><a href="./js-ffi.html"><strong>7.</strong> JavaScript Interoperation</a></li><li><a href="./tutorials.html"><strong>8.</strong> Tutorials</a></li><li><ul class="section"><li><a href="./game-of-life/introduction.html"><strong>8.1.</strong> Conway's Game of Life</a></li><li><ul class="section"><li><a href="./game-of-life/setup.html"><strong>8.1.1.</strong> Setup</a></li><li><a href="./game-of-life/rules.html"><strong>8.1.2.</strong> Rules</a></li><li><a href="./game-of-life/implementing.html"><strong>8.1.3.</strong> Implementing Life</a></li><li><a href="./game-of-life/debugging.html"><strong>8.1.4.</strong> Debugging</a></li><li><a href="./game-of-life/interactivity.html"><strong>8.1.5.</strong> Adding Interactivity</a></li><li><a href="./game-of-life/time-profiling.html"><strong>8.1.6.</strong> Time Profiling</a></li><li><a href="./game-of-life/code-size.html" class="active"><strong>8.1.7.</strong> Shrinking <code>.wasm</code> Size</a></li><li><a href="./game-of-life/publishing.html"><strong>8.1.8.</strong> Publishing</a></li></ul></li><li><a href="./wasm-pack/introduction.html"><strong>8.2.</strong> wasm-pack</a></li><li><ul class="section"><li><a href="./wasm-pack/setup.html"><strong>8.2.1.</strong> Setup</a></li><li><a href="./wasm-pack/initialize.html"><strong>8.2.2.</strong> Project Initialization</a></li><li><a href="./wasm-pack/rust-code.html"><strong>8.2.3.</strong> Rust Code</a></li><li><a href="./wasm-pack/package-code.html"><strong>8.2.4.</strong> Package Code For npm</a></li><li><a href="./wasm-pack/run-the-code.html"><strong>8.2.5.</strong> Run The Code From npm</a></li><li><a href="./wasm-pack/next-steps.html"><strong>8.2.6.</strong> Next Steps</a></li></ul></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./game-of-life/code-size.html#shrinking-wasm-size" id="shrinking-wasm-size"><h1>Shrinking <code>.wasm</code> Size</h1></a>
<p>This chapter will teach you how to optimize your <code>.wasm</code> build for a small code
size footprint, and how to identify opportunities to change your Rust source
such that less <code>.wasm</code> code is emitted.</p>
<a class="header" href="./game-of-life/code-size.html#optimizing-builds-for-code-size" id="optimizing-builds-for-code-size"><h2>Optimizing Builds for Code Size</h2></a>
<p>There are a bunch of configuration options we can use to get <code>rustc</code> to make
smaller <code>.wasm</code> binaries. In some cases, we are trading longer compile times for
smaller <code>.wasm</code> sizes. In other cases, we are trading runtime speed of the
WebAssembly for smaller code size. We should be cognizant of the trade offs of
each option, and in the cases where we trade runtime speed for code size,
profile and measure to make an informed decision about whether the trade is
worth it.</p>
<a class="header" href="./game-of-life/code-size.html#disable-debug-symbols" id="disable-debug-symbols"><h3>Disable Debug Symbols</h3></a>
<p>The section containing function name strings for debugging takes up more space
than you might think. If you aren't debugging or profiling, and want to generate
a small <code>.wasm</code> binary, then disable these names with this <code>Cargo.toml</code> setting:</p>
<pre><code class="language-toml">[profile.release]
debug = false
</code></pre>
<a class="header" href="./game-of-life/code-size.html#compiling-with-link-time-optimizations-lto" id="compiling-with-link-time-optimizations-lto"><h3>Compiling with Link Time Optimizations (LTO)</h3></a>
<p>In <code>Cargo.toml</code>, add <code>lto = true</code> in the <code>[profile.release]</code> section:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<p>This gives LLVM many more opportunities to inline and prune functions. Not only
will it make the <code>.wasm</code> smaller, but it will also make it faster at runtime!
The downside is that compilation will take longer.</p>
<a class="header" href="./game-of-life/code-size.html#tell-llvm-to-optimize-for-size-instead-of-speed" id="tell-llvm-to-optimize-for-size-instead-of-speed"><h3>Tell LLVM to Optimize for Size Instead of Speed</h3></a>
<p>LLVM's optimization passes are tuned to improve speed, not size, by default. We
can change the goal to code size by modifying the <code>[profile.release]</code> section in
<code>Cargo.toml</code> to this:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>Or, to even more aggressively optimize for size, at further potential speed
costs:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>Note that, surprisingly enough, <code>opt-level = &quot;s&quot;</code> can sometimes result in
smaller binaries than <code>opt-level = &quot;z&quot;</code>. Always measure!</p>
<a class="header" href="./game-of-life/code-size.html#use-the-wasm-opt-tool" id="use-the-wasm-opt-tool"><h3>Use the <code>wasm-opt</code> Tool</h3></a>
<p>The <a href="https://github.com/WebAssembly/binaryen">Binaryen</a> toolkit is a collection of WebAssembly-specific compiler
tools. It goes much further than LLVM's WebAssembly backend does, and using its
<code>wasm-opt</code> tool to post-process a <code>.wasm</code> binary generated by LLVM can often get
another 15-20% savings on code size. It will often produce runtime speed ups at
the same time!</p>
<pre><code class="language-bash"># Optimize for size.
wasm-opt -Os -o output.wasm input.wasm

# Optimize aggressively for size.
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O -o output.wasm input.wasm

# Optimize aggressively for speed.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<a class="header" href="./game-of-life/code-size.html#how-small-do-these-build-configurations-get-our-game-of-life-wasm-binary" id="how-small-do-these-build-configurations-get-our-game-of-life-wasm-binary"><h3>How small do these build configurations get our Game of Life <code>.wasm</code> binary?</h3></a>
<p>With the default release build configuration (without debug symbols), our
WebAssembly binary is 240,605 bytes:</p>
<pre><code>$ wc -c wasm_game_of_life_bg.wasm
240605 wasm_game_of_life_bg.wasm
</code></pre>
<p>After enabling LTO, setting <code>opt-level = &quot;z&quot;</code>, and running <code>wasm-opt -Oz</code>, the
resulting <code>.wasm</code> binary shrinks to only 37,424 bytes!</p>
<pre><code>$ wc -c wasm_game_of_life_bg.wasm
37424 wasm_game_of_life_bg.wasm
</code></pre>
<a class="header" href="./game-of-life/code-size.html#size-profiling" id="size-profiling"><h2>Size Profiling</h2></a>
<p>If tweaking build configurations to optimize for code size isn't resulting in a
small enough <code>.wasm</code> binary, it is time to do some profiling to see where the
remaining code size is coming from.</p>
<blockquote>
<p>⚡ Just like how we let time profiling guide our speed up efforts, we want to
let size profiling guide our code size shrinking efforts. Fail to do this and
you risk wasting your own time!</p>
</blockquote>
<a class="header" href="./game-of-life/code-size.html#the-twiggy-code-size-profiler" id="the-twiggy-code-size-profiler"><h3>The <code>twiggy</code> Code Size Profiler</h3></a>
<p><a href="https://github.com/rustwasm/twiggy"><code>twiggy</code> is a code size profiler</a> that supports WebAssembly as
input. It analyzes a binary's call graph to answer questions like:</p>
<ul>
<li>
<p>Why was this function included in the binary in the first place?</p>
</li>
<li>
<p>What is the <em>retained size</em> of this function? I.e. how much space would be
saved if I removed it and all the functions that become dead code after its
removal?</p>
</li>
</ul>
<style>
/* For whatever reason, the defautl mdbook fonts fonts break with the
   following box-drawing characters, hence the manual style. */
pre, code {
  font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
</style>
<pre><code class="language-text">$ twiggy top -n 20 wasm_game_of_life_bg.wasm
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────
          9158 ┊    19.65% ┊ &quot;function names&quot; subsection
          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8
          2510 ┊     5.39% ┊ &lt;str as core::fmt::Debug&gt;::fmt::he0d87479d1c208ea
          1737 ┊     3.73% ┊ data[0]
          1574 ┊     3.38% ┊ data[3]
          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5
          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d
          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced
          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b
          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605
           931 ┊     2.00% ┊ data[4]
           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05
           841 ┊     1.80% ┊ &lt;char as core::fmt::Debug&gt;::fmt::h07742d9f4a8c56f2
           813 ┊     1.74% ┊ __rust_realloc
           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85
           678 ┊     1.45% ┊ &lt;core::fmt::builders::PadAdapter&lt;'a&gt; as core::fmt::Write&gt;::write_str::h96b72fb7457d3062
           631 ┊     1.35% ┊ universe_tick
           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8
           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5
           503 ┊     1.08% ┊ &lt;&amp;'a T as core::fmt::Debug&gt;::fmt::hba207e4f7abaece6
</code></pre>
<a class="header" href="./game-of-life/code-size.html#manually-inspecting-llvm-ir" id="manually-inspecting-llvm-ir"><h3>Manually Inspecting LLVM-IR</h3></a>
<p>LLVM-IR is the final intermediate representation in the compiler toolchain
before LLVM generates WebAssembly. Therefore, it is very similar to the
WebAssembly that is ultimately emitted. More LLVM-IR generally means more
<code>.wasm</code> size, and if a function takes up 25% of the LLVM-IR, then it generally
will take up 25% of the <code>.wasm</code>. While these numbers only hold in general, the
LLVM-IR has crucial information that is not present in the <code>.wasm</code> (because of
WebAssembly's lack of a debugging format like DWARF): which subroutines were
inlined into a given function.</p>
<p>You can generate LLVM-IR with this <code>cargo</code> command:</p>
<pre><code>cargo rustc --release -- --emit llvm-ir
</code></pre>
<p>Then, you can use <code>find</code> to locate the <code>.ll</code> file containing the LLVM-IR in
<code>cargo</code>'s <code>target</code> directory:</p>
<pre><code>find target/release -type f -name '*.ll'
</code></pre>
<a class="header" href="./game-of-life/code-size.html#references" id="references"><h4>References</h4></a>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a></li>
</ul>
<a class="header" href="./game-of-life/code-size.html#more-invasive-tools-and-techniques" id="more-invasive-tools-and-techniques"><h2>More Invasive Tools and Techniques</h2></a>
<p>Tweaking build configurations to get smaller <code>.wasm</code> binaries is pretty hands
off. When you need to go the extra mile, however, you are prepared to use more
invasive techniques, like rewriting source code to avoid bloat. What follows is
a collection of get-your-hands-dirty techniques you can apply to get smaller
code sizes.</p>
<a class="header" href="./game-of-life/code-size.html#avoid-string-formatting" id="avoid-string-formatting"><h3>Avoid String Formatting</h3></a>
<p><code>format!</code>, <code>to_string</code>, etc... can bring in a lot of code bloat. If possible,
only do string formatting in debug mode, and in release mode use static strings.</p>
<a class="header" href="./game-of-life/code-size.html#avoid-panicking" id="avoid-panicking"><h3>Avoid Panicking</h3></a>
<p>This is definitely easier said than done, but tools like <code>twiggy</code> and manually
inspecting LLVM-IR can help you figure out which functions are panicking.</p>
<p>Panics do not always appear as a <code>panic!()</code> macro invocation. They arise
implicitly from many constructs, such as:</p>
<ul>
<li>
<p>Indexing a slice panics on out of bounds indices: <code>my_slice[i]</code></p>
</li>
<li>
<p>Division will panic if the divisor is zero: <code>dividend / divisor</code></p>
</li>
<li>
<p>Unwrapping an <code>Option</code> or <code>Result</code>: <code>opt.unwrap()</code> or <code>res.unwrap()</code></p>
</li>
</ul>
<p>The first two can be translated into the third. Indexing can be replaced with
fallible <code>my_slice.get(i)</code> operations. Division can be replaced with
<code>checked_div</code> calls. Now we only have a single case to contend with.</p>
<p>Unwrapping an <code>Option</code> or <code>Result</code> without panicking comes in two flavors: safe
and unsafe.</p>
<p>The safe approach is to <code>abort</code> instead of panicking when encountering a <code>None</code>
or an <code>Error</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[inline]
pub fn unwrap_abort&lt;T&gt;(o: Option&lt;T&gt;) -&gt; T {
    use std::process;
    match o {
        Some(t) =&gt; t,
        None =&gt; process::abort(),
    }
}
#}</code></pre></pre>
<p>Ultimately, panics translate into aborts in <code>wasm32-unknown-unknown</code> anyways, so
this gives you the same behavior but without the code bloat.</p>
<p>Alternatively, the <a href="https://crates.io/crates/unreachable"><code>unreachable</code> crate</a> provides an unsafe
<a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap"><code>unchecked_unwrap</code> extension method</a> for <code>Option</code> and
<code>Result</code> which tells the Rust compiler to <em>assume</em> that the <code>Option</code> is <code>Some</code>
or the <code>Result</code> is <code>Ok</code>. It is undefined behavior what happens if that
assumption does not hold. You really only want to use this unsafe approach when
you 110% <em>know</em> that the assumption holds, and the compiler just isn't smart
enough to see it. Even if you go down this route, you should have a debug build
configuration that still does the checking, and only use unchecked operations in
release builds.</p>
<a class="header" href="./game-of-life/code-size.html#avoid-allocation-or-switch-to-wee_alloc" id="avoid-allocation-or-switch-to-wee_alloc"><h3>Avoid Allocation or Switch to <code>wee_alloc</code></h3></a>
<p>Rust's default allocator for WebAssembly is a port of <code>dlmalloc</code> to Rust. It
weighs in somewhere around ten kilobytes. If you can completely avoid dynamic
allocation, then you should be able to shed those ten kilobytes.</p>
<p>Completely avoiding dynamic allocation can be very difficult. But removing
allocation from hot code paths is usually much easier (and usually helps make
those hot code paths faster, as well). In these cases, <a href="https://github.com/rustwasm/wee_alloc">replacing the default
global allocator with <code>wee_alloc</code></a> should save you most (but not
quite all) of those ten kilobytes. <code>wee_alloc</code> is an allocator designed for
situations where you need <em>some</em> kind of allocator, but do not need a
particularly fast allocator, and will happily trade allocation speed for smaller
code size.</p>
<a class="header" href="./game-of-life/code-size.html#use-trait-objects-instead-of-generic-type-parameters" id="use-trait-objects-instead-of-generic-type-parameters"><h3>Use Trait Objects Instead of Generic Type Parameters</h3></a>
<p>When you create generic functions that use type parameters, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn whatever&lt;T: MyTrait&gt;(t: T) { ... }
#}</code></pre></pre>
<p>Then <code>rustc</code> and LLVM will create a new copy of the function for each <code>T</code> type
that the function is used with. This presents many opportunities for compiler
optimizations based on which particular <code>T</code> each copy is working with, but these
copies add up quickly in terms of code size.</p>
<p>If you use trait objects instead of type parameters, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn whatever(t: Box&lt;MyTrait&gt;) { ... }
// or
fn whatever(t: &amp;MyTrait) { ... }
// etc...
#}</code></pre></pre>
<p>Then dynamic dispatch via virtual calls is used, and only a single version of
the function is emitted in the <code>.wasm</code>. The downside is the loss of the compiler
optimzation opportunities and the added cost of indirect, dynamically dispatched
function calls.</p>
<a class="header" href="./game-of-life/code-size.html#use-the-wasm-snip-tool" id="use-the-wasm-snip-tool"><h3>Use the <code>wasm-snip</code> Tool</h3></a>
<p><a href="https://github.com/fitzgen/wasm-snip"><code>wasm-snip</code> replaces a WebAssembly function's body with an <code>unreachable</code>
instruction.</a> This is a rather heavy, blunt hammer for functions that kind
of look like nails if you squint hard enough.</p>
<p>Maybe you know that some function will never be called at runtime, but the
compiler can't prove that at compile time? Snip it! Afterwards, run <code>wasm-opt</code>
again with the <code>--dce</code> flag, and all the functions that the snipped function
transitively called (which could also never be called at runtime) will get
removed too.</p>
<p>This tool is particularly useful for removing the panicking infrastructure,
since panics ultimately translate into traps anyways.</p>
<a class="header" href="./game-of-life/code-size.html#exercises" id="exercises"><h2>Exercises</h2></a>
<ul>
<li>
<p>Use <code>wasm-snip</code> to remove the panicking infrastructure functions from our Game
of Life's <code>.wasm</code> binary. How many bytes does it save?</p>
</li>
<li>
<p>Switch our Game of Life crate over to using <code>wee_alloc</code> as its global
allocator. How much size was shaved off of the <code>.wasm</code> binary?</p>
</li>
<li>
<p>We only ever instantiate a single <code>Universe</code>, so rather than providing a
constructor, we can export operations that manipulate a single <code>static mut</code>
global instance. If this global instance also uses the double buffering
technique discussed in earlier chapters, we can make those buffers also be
<code>static mut</code> globals. This removes all dynamic allocation from our Game of
Life implementation, and we can make it a <code>#![no_std]</code> crate that doesn't
include an allocator. How much size was removed from the <code>.wasm</code> by completely
removing the allocator dependency?</p>
</li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./game-of-life/time-profiling.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./game-of-life/publishing.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./game-of-life/time-profiling.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./game-of-life/publishing.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
