<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Implementing Life - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./introduction.html"><strong>1.</strong> Introduction</a></li><li><a href="./background-and-concepts.html"><strong>2.</strong> Background And Concepts</a></li><li><a href="./setup.html"><strong>3.</strong> Setup</a></li><li><a href="./hello-world.html"><strong>4.</strong> Hello World</a></li><li><a href="./tools.html"><strong>5.</strong> Tools</a></li><li><a href="./workflows.html"><strong>6.</strong> Workflows</a></li><li><a href="./js-ffi.html"><strong>7.</strong> JavaScript Interoperation</a></li><li><a href="./tutorials.html"><strong>8.</strong> Tutorials</a></li><li><ul class="section"><li><a href="./game-of-life/introduction.html"><strong>8.1.</strong> Conway's Game of Life</a></li><li><ul class="section"><li><a href="./game-of-life/setup.html"><strong>8.1.1.</strong> Setup</a></li><li><a href="./game-of-life/rules.html"><strong>8.1.2.</strong> Rules</a></li><li><a href="./game-of-life/implementing.html" class="active"><strong>8.1.3.</strong> Implementing Life</a></li><li><a href="./game-of-life/debugging.html"><strong>8.1.4.</strong> Debugging</a></li><li><a href="./game-of-life/interactivity.html"><strong>8.1.5.</strong> Adding Interactivity</a></li><li><a href="./game-of-life/time-profiling.html"><strong>8.1.6.</strong> Time Profiling</a></li><li><a href="./game-of-life/code-size.html"><strong>8.1.7.</strong> Shrinking <code>.wasm</code> Size</a></li><li><a href="./game-of-life/publishing.html"><strong>8.1.8.</strong> Publishing</a></li></ul></li><li><a href="./wasm-pack/introduction.html"><strong>8.2.</strong> wasm-pack</a></li><li><ul class="section"><li><a href="./wasm-pack/setup.html"><strong>8.2.1.</strong> Setup</a></li><li><a href="./wasm-pack/initialize.html"><strong>8.2.2.</strong> Project Initialization</a></li><li><a href="./wasm-pack/rust-code.html"><strong>8.2.3.</strong> Rust Code</a></li><li><a href="./wasm-pack/package-code.html"><strong>8.2.4.</strong> Package Code For npm</a></li><li><a href="./wasm-pack/run-the-code.html"><strong>8.2.5.</strong> Run The Code From npm</a></li><li><a href="./wasm-pack/next-steps.html"><strong>8.2.6.</strong> Next Steps</a></li></ul></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./game-of-life/implementing.html#implementing-conways-game-of-life" id="implementing-conways-game-of-life"><h1>Implementing Conway's Game of Life</h1></a>
<a class="header" href="./game-of-life/implementing.html#design" id="design"><h2>Design</h2></a>
<p>Before we dive in, we have some design choices to consider.</p>
<a class="header" href="./game-of-life/implementing.html#infinite-universe" id="infinite-universe"><h3>Infinite Universe</h3></a>
<p>The Game of Life is played in an infinite universe, but we do not have infinite
memory and compute power. Working around this rather annoying limitation usually
comes in one of three flavors:</p>
<ol>
<li>
<p>Keep track of which subset of the universe has interesting things happening,
and expand this region as needed. In the worst case, this expansion is
unbounded and the implementation will get slower and slower and eventually
run out of memory.</p>
</li>
<li>
<p>Create a fixed-size universe, where cells on the edges have fewer neighbors
than cells in the middle. The downside with this approach is that infinite
patterns, like gliders, that reach the end of the universe are snuffed out.</p>
</li>
<li>
<p>Create a fixed-size, periodic universe, where cells on the edges have
neighbors that wrap around to the other side of the universe. Because
neighbors wrap around the edges of the universe, gliders can keep running
forever.</p>
</li>
</ol>
<p>We will implement the third option.</p>
<a class="header" href="./game-of-life/implementing.html#interfacing-rust-and-javascript" id="interfacing-rust-and-javascript"><h3>Interfacing Rust and JavaScript</h3></a>
<blockquote>
<p>⚡ This is one of the most important concepts to understand and take away from
this tutorial!</p>
</blockquote>
<p>JavaScript's garbage-collected heap — where <code>Object</code>s, <code>Array</code>s, and DOM nodes
are allocated — is distinct from WebAssembly's linear memory space, where our
Rust values live. WebAssembly currently has no direct access to the
garbage-collected heap (as of April 2018, this is expected to change with the
<a href="https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md">&quot;host bindings&quot; proposal</a>). JavaScript, on the other hand, can
read and write to the WebAssembly linear memory space, but only as an
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> of scalar values (<code>u8</code>, <code>i32</code>, <code>f64</code>,
etc...). WebAssembly functions also take and return scalar values. These are the
building blocks from which all WebAssembly and JavaScript communication is
constituted.</p>
<p><code>wasm_bindgen</code> defines a common understanding of how to work with compound
structures across this boundary. It involves boxing Rust structures, and
wrapping the pointer in a JavaScript class for usability, or indexing into a
table of JavaScript objects from Rust. <code>wasm_bindgen</code> is very convenient, but it
does not remove the need to consider our data representation, and what values
and structures are passed across this boundary. Instead, think of it as a tool
for implementing the interface design you choose.</p>
<p>When designing an interface between WebAssembly and JavaScript, we want to
optimize for the following properties:</p>
<ol>
<li>
<p><strong>Minimizing copying into and out of the WebAssembly linear memory.</strong>
Unnecessary copies impose unnecessary overhead.</p>
</li>
<li>
<p><strong>Minimizing serializing and deserializing.</strong> Similar to copies, serializing
and deserializing also imposes overhead, and often imposes copying as
well. If we can pass opaque handles to a data structure — instead of
serializing it on one side, copying it into some known location in the
WebAssembly linear memory, and deserializing on the other side — we can often
reduce a lot of overhead. <code>wasm_bindgen</code> helps us define and work with opaque
handles to JavaScript <code>Object</code>s or boxed Rust structures.</p>
</li>
<li>
<p><strong>Minimizing the number of times JavaScript calls an exported WebAssembly
function, or WebAssembly calls an imported JavaScript function.</strong> These
boundary-crossing calls are analogous to syscalls in native development.
Calling across the JavaScript↔WebAssembly boundary is pretty fast, but not
quite as fast as calling JavaScript→JavaScript or WebAssembly→WebAssembly. In
the case of homogeneous calls, engines can often perform optimizations like
inlining. With heterogeneous calls, those optimizations are much harder to
perform. We don't want to design the interface such that each iteration of
our hottest loop is an out-of-line function call.</p>
</li>
</ol>
<p>Sometimes these goals are in conflict. For example, using an opaque handle to
some JavaScript <code>Object</code> from Rust avoids copies and serialization, but involves
calling JavaScript getters and setters to manipulate it. On the other hand, we
can avoid calling across the JavaScript↔WebAssembly boundary at the cost of
serializing, copying, and deserializing the <code>Object</code> into the WebAssembly linear
memory.</p>
<p>As a general rule of thumb, a good JavaScript↔WebAssembly interface design is
often one where large, long-lived data structures are implemented as Rust types
that live in the WebAssembly linear memory, and are exposed to JavaScript as
opaque handles. JavaScript calls exported WebAssembly functions that take these
opaque handles, transform their data, perform heavy computations, query the
data, and ultimately return a small, copy-able result. By only returning the
small result of the computation, we avoid copying and/or serializing everything
back and forth between the JavaScript garbage-collected heap and the WebAssembly
linear memory.</p>
<a class="header" href="./game-of-life/implementing.html#interfacing-rust-and-javascript-in-our-game-of-life" id="interfacing-rust-and-javascript-in-our-game-of-life"><h3>Interfacing Rust and JavaScript in our Game of Life</h3></a>
<p>Let's start by enumerating some hazards to avoid. We don't want to copy the
whole universe into and out of the WebAssembly linear memory on every tick. We
do not want to allocate objects for every cell in the universe, nor do we want
to impose a cross-boundary call to read and write each cell.</p>
<p>Where does this leave us? We can represent the universe as a flat array that
lives in the WebAssembly linear memory, and has a byte for each cell. <code>0</code> is a
dead cell and <code>1</code> is a live cell.</p>
<p>Here is what a 4 by 4 universe looks like in memory:</p>
<p><img src="./images/game-of-life/universe.png" alt="Screenshot of a 4 by 4 universe" /></p>
<p>To find the array index of the cell at a given row and column in the universe,
we can use this formula:</p>
<pre><code class="language-text">index(row, column, universe) = row * width(universe) + column
</code></pre>
<p>We have several ways of exposing the universe's cells to JavaScript. To begin,
we will implement <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a> for <code>Universe</code>, which we can
use to generate a Rust <code>String</code> of the cells rendered as text characters. This
Rust String is then copied from the WebAssembly linear memory into a JavaScript
String in the JavaScript's garbage-collected heap, and is then displayed by
setting HTML <code>textContent</code>. Later in the chapter, we'll evolve this
implementation to avoid copying the universe's cells between heaps and to render
to <code>&lt;canvas&gt;</code>.</p>
<p><em>Another viable design alternative would be for Rust to return a list of every
cell that changed states after each tick, instead of exposing the whole universe
to JavaScript. This way, JavaScript wouldn't need to iterate over the whole
universe when rendering, only the relevant subset. The trade off is that this
delta-based design is slightly more difficult to implement.</em></p>
<a class="header" href="./game-of-life/implementing.html#rust-implementation" id="rust-implementation"><h2>Rust Implementation</h2></a>
<p>In the last chapter, we cloned an initial project template. We will modify that
project template now.</p>
<p>Let's begin by removing the <code>alert</code> import and <code>greet</code> function from
<code>src/lib.rs</code>, and replacing them with a type definition for cells:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
#}</code></pre></pre>
<p>It is important that we have <code>#[repr(u8)]</code>, so that each cell is represented as
a single byte. It is also important that the <code>Dead</code> variant is <code>0</code> and that the
<code>Alive</code> variant is <code>1</code>, so that we can easily count a cell's live neighbors with
addition.</p>
<p>Next, let's define the universe. The universe has a width and a height, and a
vector of cells of length <code>width * height</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
#}</code></pre></pre>
<p>To access the cell at a given row and column, we translate the row and column
into an index into the cells vector, as described earlier:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Universe {
    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }

    // ...
}
#}</code></pre></pre>
<p>In order to calculate the next state of a cell, we need to get a count of how
many of its neighbors are alive. Let's write a <code>live_neighbor_count</code> method to
do just that!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Universe {
    // ...

    fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 &amp;&amp; delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
#}</code></pre></pre>
<p>The <code>live_neighbor_count</code> method uses deltas and modulo to avoid special casing
the edges of the universe with <code>if</code>s. When applying a delta of <code>-1</code>, we <em>add</em>
<code>self.height - 1</code> and let the modulo do its thing, rather than attempting to
subtract <code>1</code>. <code>row</code> and <code>column</code> can be <code>0</code>, and if we attempted to subtract <code>1</code>
from them, there would be an unsigned integer underflow.</p>
<p>Now we have everything we need to compute the next generation from the current
one! Each of the Game's rules follows a straightforward translation into a
condition on a <code>match</code> expression. Additionally, because we want JavaScript to
control when ticks happen, we will put this method inside a <code>#[wasm_bindgen]</code>
block, so that it gets exposed to JavaScript.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&amp;mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
#}</code></pre></pre>
<p>So far, the state of the universe is represented as a vector of cells. To make
this human readable, let's implement a basic text renderer. The idea is to write
the universe line by line as text, and for each cell that is alive, print the
unicode character <code>◼️</code> (&quot;black medium square&quot;). For dead cells, we'll print <code>◻️</code>
(a &quot;white medium square&quot;).</p>
<p>By implementing the <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a> trait from Rust's standard library, we can add a
way to format a structure in a user-facing manner. This will also automatically
give us a <a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { &quot;◻️&quot; } else { &quot;◼️&quot; };
                write!(f, &quot;{}&quot;, symbol)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
#}</code></pre></pre>
<p>Finally, we define a constructor that initializes the universe with an
interesting pattern of live and dead cells, as well as a <code>render</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -&gt; Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&amp;self) -&gt; String {
        self.to_string()
    }
}
#}</code></pre></pre>
<p>With that, the Rust half of our Game of Life implementation is complete!</p>
<a class="header" href="./game-of-life/implementing.html#rendering-with-javascript" id="rendering-with-javascript"><h2>Rendering with JavaScript</h2></a>
<p>First, let's add a <code>&lt;pre&gt;</code> element to our HTML to render the universe to:</p>
<pre><code class="language-html">&lt;body&gt;
    &lt;pre id=&quot;game-of-life-canvas&quot;&gt;&lt;/pre&gt;
    &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>Additionally, we want the <code>&lt;pre&gt;</code> centered in the middle of the Web page. We
can use CSS flex boxes to accomplish this task. Add the following <code>&lt;style&gt;</code> tag
inside <code>index.html</code>'s <code>&lt;head&gt;</code>:</p>
<pre><code class="language-html">&lt;style&gt;
    body {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }
&lt;/style&gt;
</code></pre>
<p>At the top of <code>index.js</code>, let's fix our import to bring in the <code>Universe</code> rather
than the old <code>greet</code> function:</p>
<pre><code class="language-js">import { Universe } from &quot;./wasm_game_of_life&quot;;
</code></pre>
<p>Also, let's get that <code>&lt;pre&gt;</code> element we just added and instantiate a new
universe:</p>
<pre><code class="language-js">const pre = document.getElementById(&quot;game-of-life-canvas&quot;);
const universe = Universe.new();
</code></pre>
<p>The JavaScript runs in a <code>requestAnimationFrame</code> loop. On each iteration, it
draws the current universe to the <code>&lt;pre&gt;</code>, and then calls <code>Universe::tick</code>.</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>To start the rendering process, all we have to do is make the initial call for
the first iteration of the rendering loop:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<p>This is what it looks like right now:</p>
<p><a href="./images/game-of-life/initial-game-of-life-pre.png"><img src="./images/game-of-life/initial-game-of-life-pre.png" alt="Screenshot of the Game of Life implementation with text rendering" /></a></p>
<a class="header" href="./game-of-life/implementing.html#rendering-to-canvas-directly-from-memory" id="rendering-to-canvas-directly-from-memory"><h2>Rendering to Canvas Directly from Memory</h2></a>
<p>Generating (and allocating) a <code>String</code> in Rust and then having <code>wasm-bindgen</code>
convert it to a valid JavaScript string makes unnecessary copies of the
universe's cells. Instead of our current <code>render</code> method, we can return a
pointer to the start of the cells array. The JavaScript code knows the width and
height of the universe, and can read the bytes that make up the cells directly.
This design does not copy the universe's cells or tax the JavaScript garbage
collector with allocations, but we must directly read the cells' bytes from
WebAssembly's linear memory in JavaScript. Instead of rendering unicode text,
we'll switch to using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>. We will use this design in the rest of
the tutorial.</p>
<p>First, let's replace the <code>pre</code> we added earlier with a <code>&lt;canvas&gt;</code> we will render
into (it too should be within the <code>&lt;body&gt;</code>, before the <code>&lt;script&gt;</code> that loads our
JavaScript):</p>
<pre><code class="language-html">&lt;body&gt;
    &lt;canvas id=&quot;game-of-life-canvas&quot;&gt;&lt;/canvas&gt;
    &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>To get the necessary information from the Rust implementation, we'll need to add
some more getter functions for a universe's width, height, and pointer to its
cells array. All of these are exposed to JavaScript as well.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&amp;self) -&gt; u32 {
        self.width
    }

    pub fn height(&amp;self) -&gt; u32 {
        self.height
    }

    pub fn cells(&amp;self) -&gt; *const Cell {
        self.cells.as_ptr()
    }
}
#}</code></pre></pre>
<p>Next, let's define some constants that JavaScript will use when rendering the
canvas:</p>
<pre><code class="language-js">const CELL_SIZE = 5; // px
const GRID_COLOR = &quot;#CCCCCC&quot;;
const DEAD_COLOR = &quot;#FFFFFF&quot;;
const ALIVE_COLOR = &quot;#000000&quot;;

// These must match `Cell::Alive` and `Cell::Dead` in `src/lib.rs`.
const DEAD = 0;
const ALIVE = 1;
</code></pre>
<p>Now, let's rewrite our current JS code (except for the import) to no longer
write to the <code>&lt;pre&gt;</code> but instead draw to the <code>&lt;canvas&gt;</code>:</p>
<pre><code class="language-js">// Construct the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById(&quot;game-of-life-canvas&quot;);
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () =&gt; {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>To draw the grid between cells, we draw a set of equally-spaced horizontal
lines, and a set of equally-spaced vertical lines. These lines criss-cross to
form the grid.</p>
<pre><code class="language-js">const drawGrid = () =&gt; {
  ctx.beginPath();
  ctx.lineWidth = 1 / window.devicePixelRatio;
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i &lt;= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j &lt;= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<p>To draw the cells, we get the cells pointer into the WebAssembly linear memory
from the universe, construct a <code>Uint8Array</code> overlaying the cells buffer, iterate
over each cell, and draw a white or black rectangle depending on whether the
cell is dead or alive, respectively. By working with pointers and overlays, we
avoid copying the cells across the boundary on every tick.</p>
<pre><code class="language-js">// Import the WebAssembly memory at the top of the file.
import { memory } from &quot;./wasm_game_of_life_bg&quot;;

// ...

const getIndex = (row, column) =&gt; {
  return row * width + column;
};

const drawCells = () =&gt; {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === DEAD
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<p>To start the rendering process, we'll use the same code as above to start the
first iteration of the rendering loop:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<a class="header" href="./game-of-life/implementing.html#it-works" id="it-works"><h2>It Works!</h2></a>
<p>Rebuild the WebAssembly and bindings glue:</p>
<pre><code>npm run build-debug
</code></pre>
<p>Make sure your development server is still running. If it isn't, start it again:</p>
<pre><code>npm run serve
</code></pre>
<p>If you refresh <a href="http://localhost:8080/">http://localhost:8080/</a>, you should be
greeted with an exciting display of life!</p>
<p><a href="./images/game-of-life/initial-game-of-life.png"><img src="./images/game-of-life/initial-game-of-life.png" alt="Screenshot of the Game of Life implementation" /></a></p>
<p>You can find the complete source for this implementation in the <code>chapter-one</code>
branch.</p>
<p>There is also a really neat algorithm for implementing the Game of Life called <a href="https://en.wikipedia.org/wiki/Hashlife">hashlife</a>. It uses aggressive memoizing and can actually get <em>exponentially faster</em> to compute future generations the longer it runs! Given that, you might be wondering why we didn't implement hashlife in this tutorial. It is out of scope for this text, where we are focusing on Rust and WebAssembly integration, but we highly encourage you to go learn about hashlife on your own!</p>
<a class="header" href="./game-of-life/implementing.html#exercises" id="exercises"><h2>Exercises</h2></a>
<ul>
<li>
<p>Initialize the universe with a single space ship.</p>
</li>
<li>
<p>Instead of hard-coding the initial universe, generate a random one, where each
cell has a fifty-fifty chance of being alive or dead.</p>
<p><em>Hint: use <code>wasm_bindgen</code> to import the <code>Math.random</code> JavaScript function:</em></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = Math)]
    fn random() -&gt; f64;
}
#}</code></pre></pre>
</li>
<li>
<p>Representing each cell with a byte makes iterating over cells easy, but it
comes at the cost of wasting memory. Each byte is eight bits, but we only
require a single bit to represent whether each cell is alive or dead. Refactor
the data representation so that each cell uses only a single bit of space.</p>
</li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./game-of-life/rules.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./game-of-life/debugging.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./game-of-life/rules.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./game-of-life/debugging.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
